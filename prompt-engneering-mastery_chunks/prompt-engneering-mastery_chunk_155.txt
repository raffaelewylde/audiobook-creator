hain  = bad_first_input  | prompt
A Python dictionary with a value of 18 will not create a runnable LCEL
chain. However , all of the following implementations will work:
# All of these chains enforce the runnable interface:
first_good_input  = {"film_required_age" : itemgetter ("
# Creating a dictionary within a RunnableLambda:
second_good_input  = RunnableLambda (lambda x: { "film_
x["film_required_age" ] } )
third_good_input  = RunnablePassthrough ()
fourth_good_input  = {"film_required_age" : RunnablePas
# You can also create a chain starting with RunnableP
first_good_chain  = first_good_input  | prompt
second_good_chain  = second_good_input  | prompt
third_good_chain  = third_good_input  | prompt
fourth_good_chain  = fourth_good_input  | prompt
first_good_chain .invoke({
    "film_required_age" : 18
}) # ...Sequential chains are great at incrementally building generated knowledge
that is used by future chains, but they often yield slower response times due
to their sequential nature. As such, SequentialChain  data pipelines are
best suited for server -side tasks, where immediate responses are not a
priority and users aren’ t awaiting real-time feedback.
Document Chains
Let’s imagine that before accepting your generated story , the local publisher
has requested that you provide a summary based on all of the character
scripts. This is a good use case for document chains  because you need to
provide an LLM with a lar ge amount of text that wouldn’ t fit within a single
LLM request due to the context length restrictions.
Before delving into the code, let’ s first get a sense of the broader picture.
The script you are going to see performs a text summarization task on a
collection of scenes.
Remember to install Pandas with pip install pandas .
Now , let’s start with the first set of code:
from langchain_text_splitters  import CharacterTextSpl
from langchain.chains.summarize  import load_summarize
import pandas as pdThese lines are importing all the necessary tools yo