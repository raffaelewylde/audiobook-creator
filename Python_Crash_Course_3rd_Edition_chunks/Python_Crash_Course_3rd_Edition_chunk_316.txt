the walk should take. The
class needs three attributes: one variable to track the number of points in the
walk, and two lists to store the x- and y-coordinates of each point in the
walk.
We’ll only need two methods for the RandomWalk  class: the
__init__()  method and fill_walk() , which will calculate the points
in the walk. Let’ s start with the __init__()  method:
random_walk.py
❶ from random import choice
class RandomWalk:
    """A class to generate random walks."""
❷     def __init__(self, num_points=5000):
        """Initialize attributes of a walk."""
        self.num_points = num_points        # All walks start at (0, 0).
❸         self.x_values = [0]
        self.y_values = [0]
To make random decisions, we’ll store possible moves in a list and use the
choice()  function (from the random  module) to decide which move to
make each time a step is taken ❶. We set the default number of points in a
walk to 5000 , which is lar ge enough to generate some interesting patterns
but small enough to generate walks quickly ❷. Then we make two lists to
hold the x- and y-values, and we start each walk at the point (0, 0) ❸.
Choosing Dir ections
We’ll use the fill_walk()  method to determine the full sequence of
points in the walk. Add this method to random_walk.py :
random_walk.py
    def fill_walk(self):
        """Calculate all the points in the walk."""
        # Keep taking steps until the walk reaches t
❶         while len(self.x_values) < self.num_points:
            # Decide which direction to go, and how 
❷             x_direction = choice([1, -1])            x_distance = choice([0, 1, 2, 3, 4])
❸             x_step = x_direction * x_distance
            y_direction = choice([1, -1])
            y_distance = choice([0, 1, 2, 3, 4])
❹             y_step = y_direction * y_distance
            # Reject moves that go nowhere.
❺             if x_step == 0 and y_step == 0:
                continue
            # Calculate the new position.
❻             x = self.x_values[