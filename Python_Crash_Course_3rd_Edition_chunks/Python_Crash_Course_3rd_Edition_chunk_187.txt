t Car
my_new_car = Car('audi', 'a4', 2024)
print(my_new_car.get_descriptive_name())
my_new_car.odometer_reading = 23
my_new_car.read_odometer()
The import  statement ❶ tells Python to open the car  module and
import the class Car . Now we can use the Car  class as if it were defined
in this file. The output is the same as we saw earlier:
2024 Audi A4This car has 23 miles on it.
Importing classes is an ef fective way to program. Picture how long this
program file would be if the entire Car  class were included. When you
instead move the class to a module and import the module, you still get all
the same functionality , but you keep your main program file clean and easy
to read. You also store most of the logic in separate files; once your classes
work as you want them to, you can leave those files alone and focus on the
higher -level logic of your main program.
Storing Multiple Classes in a Module
You can store as many classes as you need in a single module, although
each class in a module should be related somehow . The classes Battery
and ElectricCar  both help represent cars, so let’ s add them to the
module car.py.
car.py
"""A set of classes used to represent gas and electri
class Car:
    --snip--
class Battery:    """A simple attempt to model a battery for an ele
    def __init__(self, battery_size=40):
        """Initialize the battery's attributes."""
        self.battery_size = battery_size
    def describe_battery(self):
        """Print a statement describing the battery s
        print(f"This car has a {self.battery_size}-kW
    def get_range(self):
        """Print a statement about the range this bat
        if self.battery_size == 40:
            range = 150
        elif self.battery_size == 65:
            range = 225
        print(f"This car can go about {range} miles o
class ElectricCar(Car):
    """Models aspects of a car, specific to electric 
    def __init__(self, make, model, year):
        """
        Initialize attributes of the parent class.