e into a rendered image."""
        rounded_score = round(self.stats.score, -1)
        score_str = f"{rounded_score:,}"
        self.score_image = self.font.render(score_str
                self.text_color, self.settings.bg_col
        --snip--
The round()  function normally rounds a float to a set number of decimal
places given as the second ar gument. However , when you pass a negative
number as the second ar gument, round()  will round the value to the
nearest 10, 100, 1,000, and so on. This code tells Python to round the value
of stats.score  to the nearest 10 and assign it to rounded_score .
We then use a format specifier in the f-string for the score. A format
specifier  is a special sequence of characters that modifies the way avariable’ s value is presented. In this case the sequence :, tells Python to
insert commas at appropriate places in the numerical value that’ s provided.
This results in strings like 1,000,000  instead of 1000000 .
Now when you run the game, you should see a neatly formatted, rounded
score even when you rack up lots of points, as shown in Figure 14-3 .
Figure 14-3 : A rounded scor e with comma separators
High Scor es
Every player wants to beat a game’ s high score, so let’ s track and report
high scores to give players something to work toward. We’ll store highscores in GameStats :
game_stats.py
    def __init__(self, ai_game):
        --snip--
        # High score should never be reset.
        self.high_score = 0
Because the high score should never be reset, we initialize high_score
in __init__()  rather than in reset_stats() .
Next, we’ll modify Scoreboard  to display the high score. Let’ s start with
the __init__()  method:
scoreboard.py
    def __init__(self, ai_game):
        --snip--
        # Prepare the initial score images.
        self.prep_score()
❶         self.prep_high_score()
The high score will be displayed separately from the score, so we need a
new method, prep_high_score() , to prepare the high-score image ❶.Here’ 