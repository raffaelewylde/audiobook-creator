s well. The function will work no
matter how many additional key-value pairs are provided in the function
call.
You can mix positional, keyword, and arbitrary values in many dif ferent
ways when writing your own functions. It’ s useful to know that all these
argument types exist because you’ll see them often when you start reading
other people’ s code. It takes practice to use the dif ferent types correctly and
to know when to use each type. For now , remember to use the simplest
approach that gets the job done. As you progress, you’ll learn to use the
most ef ficient approach each time.NOTE
You’ll often see the parameter name **kwargs  used to collect
nonspecific keywor d arguments.TRY IT YOURSELF
8-12. Sandwiches:  Write a function that accepts a list of items a person wants on a sandwich.
The function should have one parameter that collects as many items as the function call
provides, and it should print a summary of the sandwich that’ s being ordered. Call the function
three times, using a dif ferent number of ar guments each time.
8-13. User  Profile:  Start with a copy of user_pr ofile.py  from page 148 . Build a profile of
yourself by calling build_profile() , using your first and last names and three other key-
value pairs that describe you.
8-14. Cars:  Write a function that stores information about a car in a dictionary . The function
should always receive a manufacturer and a model name. It should then accept an arbitrary
number of keyword ar guments. Call the function with the required information and two other
name-value pairs, such as a color or an optional feature. Your function should work for a call
like this one:
car = make_car('subaru', 'outback', color='blue', tow_package=True)
Print the dictionary that’ s returned to make sure all the information was stored correctly .
Storing Your Functions in Modules
One advantage of functions is the way they separate blocks of code from
your main program. When you use descriptive names for your functions,
you