at
depends on the try  block succeeding is added to the else  block. In this
case, if the division operation is successful, we use the else  block to print
the result ❸.
The except  block tells Python how to respond when a
ZeroDivisionError  arises ❷. If the try  block doesn’ t succeed
because of a division-by-zero error , we print a friendly message telling theuser how to avoid this kind of error . The program continues to run, and the
user never sees a traceback:
Give me two numbers, and I'll divide them.
Enter 'q' to quit.
First number: 5
Second number: 0
You can't divide by 0!
First number: 5
Second number: 2
2.5
First number: q
The only code that should go in a try  block is code that might cause an
exception to be raised. Sometimes you’ll have additional code that should
run only if the try  block was successful; this code goes in the else
block. The except  block tells Python what to do in case a certain
exception arises when it tries to run the code in the try  block.
By anticipating likely sources of errors, you can write robust programs that
continue to run even when they encounter invalid data and missing
resources. Your code will be resistant to innocent user mistakes and
malicious attacks.Handling the FileNotFoundErr or Exception
One common issue when working with files is handling missing files. The
file you’re looking for might be in a dif ferent location, the filename might
be misspelled, or the file might not exist at all. You can handle all of these
situations with a try -except  block.
Let’s try to read a file that doesn’ t exist. The following program tries to read
in the contents of Alice in W onderland , but I haven’ t saved the file alice.txt
in the same directory as alice.py :
alice.py
from pathlib import Path
path = Path('alice.txt')
contents = path.read_text(encoding='utf-8')
Note that we’re using read_text()  in a slightly dif ferent way here than
what you saw earlier . The encoding  argument is needed when your
system’ s default encoding 