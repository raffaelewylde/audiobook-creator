elf.battery_size}-kW
my_leaf = ElectricCar('nissan', 'leaf', 2024)
print(my_leaf.get_descriptive_name())
my_leaf.describe_battery()
We add a new attribute self.battery_size  and set its initial value to
40 ❶. This attribute will be associated with all instances created from theElectricCar  class but won’ t be associated with any instances of Car .
We also add a method called describe_battery()  that prints
information about the battery ❷. When we call this method, we get a
description that is clearly specific to an electric car:
2024 Nissan Leaf
This car has a 40-kWh battery.
There’ s no limit to how much you can specialize the ElectricCar  class.
You can add as many attributes and methods as you need to model an
electric car to whatever degree of accuracy you need. An attribute or
method that could belong to any car , rather than one that’ s specific to an
electric car , should be added to the Car  class instead of the
ElectricCar  class. Then anyone who uses the Car  class will have that
functionality available as well, and the ElectricCar  class will only
contain code for the information and behavior specific to electric vehicles.
Overriding Methods fr om the Par ent Class
You can override any method from the parent class that doesn’ t fit what
you’re trying to model with the child class. To do this, you define a method
in the child class with the same name as the method you want to override in
the parent class. Python will disregard the parent class method and only pay
attention to the method you define in the child class.Say the class Car  had a method called fill_gas_tank() . This method
is meaningless for an all-electric vehicle, so you might want to override this
method. Here’ s one way to do that:
class ElectricCar(Car):
    --snip--
    def fill_gas_tank(self):
        """Electric cars don't have gas tanks."""
        print("This car doesn't have a gas tank!")
Now if someone tries to call fill_gas_tank()  with an electric car ,
Python will ignore the metho