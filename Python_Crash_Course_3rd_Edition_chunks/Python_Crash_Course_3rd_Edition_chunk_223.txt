t case
with full coverage  includes a full range of unit tests covering all the
possible ways you can use a function. Achieving full coverage on a lar ge
project can be daunting. It’ s often good enough to write tests for your
code’ s critical behaviors and then aim for full coverage only if the project
starts to see widespread use.
A Passing Test
With pytest , writing your first unit test is pretty straightforward. We’ll
write a single test function. The test function will call the function we’re
testing, and we’ll make an assertion about the value that’ s returned. If our
assertion is correct, the test will pass; if the assertion is incorrect, the test
will fail.
Here’ s the first test of the function get_formatted_name() :test_name_function.py
from name_function import get_formatted_name
❶ def test_first_last_name():
    """Do names like 'Janis Joplin' work?"""
❷     formatted_name = get_formatted_name('janis', 'jop
❸     assert formatted_name == 'Janis Joplin'
Before we run the test, let’ s take a closer look at this function. The name of
a test file is important; it must start with test_ . When we ask pytest  to
run the tests we’ve written, it will look for any file that begins with test_ ,
and run all of the tests it finds in that file.
In the test file, we first import the function that we want to test:
get_formatted_name() . Then we define a test function: in this case,
test_first_last_name()  ❶. This is a longer function name than
we’ve been using, for a good reason. First, test functions need to start with
the word test, followed by an underscore. Any function that starts with
test_  will be discover ed by pytest , and will be run as part of the
testing process.
Also, test names should be longer and more descriptive than a typical
function name. You’ll never call the function yourself; pytest  will find
the function and run it for you. Test function names should be long enoughthat if you see the function name in a test report, you’ll have a good sense
of w