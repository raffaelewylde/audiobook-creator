call fill_walk() .
To visualize the walk, we feed the walk’ s x- and y-values to scatter()
and choose an appropriate dot size ❷. By default, Matplotlib scales each
axis independently . But that approach would stretch most walks out
horizontally or vertically . Here we use the set_aspect()  method to
specify that both axes should have equal spacing between tick marks ❸.
Figure 15-9  shows the resulting plot with 5,000 points. The images in this
section omit Matplotlib’ s viewer , but you’ll continue to see it when you run
rw_visual.py .Figure 15-9 : A random walk with 5,000 points
Generating Multiple Random Walks
Every random walk is dif ferent, and it’ s fun to explore the various patterns
that can be generated. One way to use the preceding code to make multiple
walks without having to run the program several times is to wrap it in a
while  loop, like this:
rw_visual.py
import matplotlib.pyplot as plt
from random_walk import RandomWalk
# Keep making new walks, as long as the program is acwhile True:
    # Make a random walk.
    --snip--
    plt.show()
    keep_running = input("Make another walk? (y/n): "
    if keep_running == 'n':
        break
This code generates a random walk, displays it in Matplotlib’ s viewer , and
pauses with the viewer open. When you close the viewer , you’ll be asked
whether you want to generate another walk. If you generate a few walks,
you should see some that stay near the starting point, some that wander of f
mostly in one direction, some that have thin sections connecting lar ger
groups of points, and many other kinds of walks. When you want to end the
program, press N.
Styling the Walk
In this section, we’ll customize our plots to emphasize the important
characteristics of each walk and deemphasize distracting elements. To do
so, we identify the characteristics we want to emphasize, such as where the
walk began, where it ended, and the path taken. Next, we identify the
characteristics to deemphasize, such as tick marks and labels. Th