tion returns the next line
in the file, starting from the beginning of the file. Here we call next()
only once, so we get the first line of the file, which contains the file headers
❸. We assign the data that’ s returned to header_row . As you can see,
header_row  contains meaningful, weather -related headers that tell us
what information each line of data holds:
['STATION', 'NAME', 'DATE', 'TAVG', 'TMAX', 'TMIN']
The reader  object processes the first line of comma-separated values in
the file and stores each value as an item in a list. The header STATIONrepresents the code for the weather station that recorded this data. The
position of this header tells us that the first value in each line will be the
weather station code. The NAME  header indicates that the second value in
each line is the name of the weather station that made the recording. The
rest of the headers specify what kinds of information were recorded in each
reading. The data we’re most interested in for now are the date ( DATE ), the
high temperature ( TMAX ), and the low temperature ( TMIN ). This is a
simple dataset that contains only temperature-related data. When you
download your own weather data, you can choose to include a number of
other measurements relating to wind speed, wind direction, and
precipitation data.
Printing the Headers and Their  Positions
To make it easier to understand the file header data, let’ s print each header
and its position in the list:
sitka_highs.py
--snip--
reader = csv.reader(lines)
header_row = next(reader)
for index, column_header in enumerate(header_row):
    print(index, column_header)The enumerate()  function returns both the index of each item and the
value of each item as you loop through a list. (Note that we’ve removed the
line print(header_row)  in favor of this more detailed version.)
Here’ s the output showing the index of each header:
0 STATION
1 NAME
2 DATE
3 TAVG
4 TMAX
5 TMIN
We can see that the dates and their high temperatures are stored in colu